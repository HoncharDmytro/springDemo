Chapter 03 Inversion of Control(IoC):

	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	XmlBeanDefinitionReader rdr = new XmlBeanDefinitionReader(factory); //OR// PropertiesBeanDefinitionReader //OR// DefaultListableBeanFactory
	rdr.loadBeanDefinitions(new ClassPathResource("spring/xml-bean-factory-config.xml"));
	Oracle oracle = (Oracle) factory.getBean("oracle");

	GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
	ctx.load("classpath:spring/app-context-annotation.xml");
	ctx.refresh();
	MessageProvider messageProvider = ctx.getBean("provider", MessageProvider.class);
	
	GenericXmlApplicationContext
	GenericApplicationContext
	AnnotationConfigApplicationContext
	AnnotationConfigWebApplicationContext
 	ConfigurationClassPostProcessor
	ClassPathXmlApplicationContext
	ApplicationContext

	PropertySourcesPlaceholderConfigurer

	@Configuration
 	@ImportResource("classpath:/com/acme/database-config.xml")
 	public class AppConfig {
     		@Inject DataSource dataSource; // from XML // or  @Autowired DataSource dataSource;
    		@Bean
     		public MyBean myBean() {
         		// inject the XML-defined dataSource bean
         		return new MyBean(this.dataSource);
     		}
 	}

	<bean id="targetByName" autowire="byName"// autowire="byType" // autowire="constructor"
	class="com.apress.prospring5.ch3.xml.Target"
	lazy-init="true"/>


Chapter 04 Configuration, context and Bean life cycle:

	<bean id="singerOne"
	class="com.apress.prospring5.ch4.Singer"
	init-method="init" p:name="John Mayer" p:age="39"/>

	interfaces InitializingBean, DisposableBean; afterPropertiesSet(){}, destroy(){} 

	@PostConstruct
	public void init() {
		//initialisation that performed after constructor is called
	}

	@PreDestroy
	public void destroy() {
		//some action doing with bean destruction
	}

	@Lazy
	@Bean(initMethod = "init")
	Singer singerOne() {
		Singer singerOne = new Singer();
		singerOne.setName("John Mayer");
		singerOne.setAge(39);
		return singerOne;
	}

	<context:annotation-config/>
	<bеаn id="destructiveBean"
		class="com.apress.prospring5.ch4.DestructiveBeanWithJSR250"
		p:filePath="#(systemProperties'java.io.tmpdir')
		#(systemProperties'file.separator')test.txt"/>

	org.springframework.core.io.Resource : contentLength (), exists (), getDescription (),
	getFile (), getFileName (), getURI (), getURL (), isOpen (), isReadable (), lastModified() 
	and createRelative()

	File file = File.createTempFile("test", "txt");
	file.deleteOnExit();
	Resource resl = ctx.getResource("file://" + file.getPath());
	Resource res2 = ctx.getResource("classpath:test.txt");
	Resource resЗ = ctx.getResource("http://www.google.com");

@Bean, @Configuration, @Component, @ComponentScan, @Service, @Resource, @Repository, @EnableTransactionManagement, @Transactional, @PropertySource, 	@Value, @Lazy, @Scope, 	@DependsOn, @Autowired, @PostConstruct, @PreDestroy, @SuppressWarnings, @MappedSuperclass, @Id, @EmbeddedId, @GeneratedValue, @Column, @Transient, @Version, @Entity, @Table, @Temporal, @OneToMany, @ManyToOne, @ManyToMany,  @JoinColumn, @NamedQueries, @NamedQuery, @TestInstance, @BeforeAll, @AfterAll, @Test, @Import, @ImportResource, @Inject, @Named, @RunWith, @ContextConfiguration, @AliasFor, @PropertySource, @Qualifier, @SpringBootApplication, @EnableAutoConfiguration, @EnableWebSecurity, @EnableGlobalMethodSecurity, @Controller, @RestController, @RequestMapping, @PathVariable, @RequestParam, @ModelAttribute, @SessionAttributes, @SessionAttribute, @RequestBody, @ResponseBody, @RequestHeader, @ResponseHeader, @Required, @CookieValue, @PathVariable, @RequestParam, @ModelAttribute, @SessionAttributes, @PreAuthorize, @GetMapping, @SpringBootTest, @MockBean, @Validated, @ConditionalOnJava, @ConditionalOnProperty, @ConditionalOnWebApplication, @ConditionalOnClass, @Override, @SuppressWarnings, @Deprecated, @SafeVarargs, @FunctionalInterface, @Native, @FunctionalInterface, @Target, @Retention, @Inherited, @Documented, @Repeatable, @GuardedBy, @Immutable, @NotThreadSafe, @ThreadSafe, @NotNull, @NotNullOrEmpty, @ValueObject, @Rollback, @Slf4j, @Profile, @ActiveProfiles, @Aspect, @Pointcut, @Before, @After, @Around, @AspectJ, @EnableAspectJAutoProxy, @AdviceRequired, 

	@Autowired
	Environment env;
	ConfigurableEnvironment env;

Chater 05 Aspect-oriented programming(AOP):

	pass


Chapter 06 JDBC, Spring Data:

	DriverManagerDataSource не поддерживается пул соединений с базой данных, только для тестирования, конфигурация:
	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource"
		p:driverClassName="${jdbc.driverClassName}"
		p:url="$(jdbc.url)"
		p:username="${jdbc.username}" //jdbc.user in pg
		p:password="${jdbc.password}"/>
	<context:property-placeholder location="classpath:db/jdbc.properties"/> //OR// <util:properties id="jdbc" location="classpath:db/jdbc2.properties"/>
	//jdbc.driverClassName=com.mysql.cj.jdbc.Driver
	//jdbc.url= jdbc:mysql://localhost:3306/musicdb?useSSL=true
	//jdbc.username=name
	//jdbc.password=pass
	
	В реальных приложениях используй нормальный источник данных, например BasicDataSource(Project Apache Commons):
		<bean id="dataSource"
			class="org.apache.commons.dbcp2.BasicDataSource" destroy-method="close"
			---

	Можно воспользоватся пулом соединений контейнера через интерфейс JNDI:
		<bean id="dataSource"
			class="org.springframework.jndi.JndiObjectFactoryBean" //OR// <jee:jndi-lookup jndi-name="java:comp/env/jdbc/musicdb" />
			p:jndiName="java:comp/env/jdbc/musicdb"/>
			<root-node>
				<resource-ref>
					<res-ref-name>jdbc/musicdb</res-ref-name>
					<res-type>javax.sql.DataSource</res-type>
					<res-auth>Container</res-auth>
				</resource-ref>
			</root-node>		
	
Chapter 07 Hibernate:

	All in module 7.


Chapter 08 JPA:

	EntityManagerFactory -> EntityManager интерфейс, занимается поддержкой контекста сохраняемости, в котором будут храниться все экземпляры сущностей, управляемые этим контекстом. Аналог SessionFactory -> Session из Hibernate.
	HQL -> JPQL языки запросов.
	Есть три типа конфигурации: 
		1. LocalEntityManagerFactoryBean - не поддерживается внедрение источника данных, а следовательно, нельзя принимать участие в 					глобальных транзакциях.
		2. JNDI - применяется для совместимого с платформой JEE 6 контейнера, в который сервер приложений производит начальную загрузку 				единицы сохраняемости JPA на основе информации в дескрипторах развертывания. Конфигурация віполняется в META-INF/persistence.xml
		3. LocalContainerEntityManagerFactoryBean - поддерживается внедрение источника данных и допускается участие как в локальных, так и 				в глобальных транзакциях.
	
	Запрашивание результатов специального типа с помощью выражения конструктора с помощью JPQL: em(EntityManager)
		public List<SingerSummary> findAll () {
			List<SingerSummary> result = em.createQuery("select new com.apress.prospring5.ch8.view.SingerSumrnary("s.firstName,"
				+ " s.lastName, a.title) from Singer s "
				+ "left join s.albums а where a.releaseDate="
				+ "(select max(a2.releaseDate) :"
				+ "from Album а2 where a2.singer.id = s.id)", SingerSummary.class).getResultList();
			return result;
		}
	
	Выборка: Album album = singer.getAlbums().stream().filter(a -> a.getTitle().equals("Battle Studies")).findFirst().get();
	
	Выборка с помощью собственных запросов(native query):
		final static String ALL_SINGER_NATIVE_QUERY = "select id, first name, last_name, Ьirth_date, version from singer";
		public List<Singer> findAllByNativeQuery() {
			return em.createNativeQuery(ALL_SINGER_NATIVE_QUERY,Singer.class).getResultList();
		}
	
	Собственный запрос с преобразованием результирующего набора SQL:
		@Entity
		@TaЬle(name = "singer")
		@SqlResultSetMapping { (name="singerResult", entities=@EntityResult(entityClass=Singer.class) }
		public class Singer implements Serializable { ... }

	Criteria API:
		?
		?
		?
		?
		?
		org.hibernate.jpamodelgen.JPAМetaModelEntityProcessor
	
Chapter 09 Transactions:

	Для транзакций и управления ими в каркасе Spring вместе с интерфейсом PlatformTransactionManager применяются интерфейсы TransactionDefinition и 	TransactionStatus.

	Транзакции обладают четырьмя хорошо известными свойствами ACID (atomicity, coпsisteпcy, isolation, durabllity - атомарность, согласованность, 		изолированность, долговечность), и за их поддержку отвечают транзакционные ресурсы.

	TransactionDefinition.ISOLAТION SERIALIZABLE
	getPropagationBehavior(PROPAGATION_REQUIRED)

	ISOLATION_DEFAULT - Использует уровень изоляции базы данных.
	ISOLATION_READ_UNCOММITTED - Самый низкий уровень изоляции, имеет доступ к не закомиченным данным(грязное чтение).
	ISOLATION_READ_СОММIТТЕD - Стандартный уровень изоляции в большинстве баз данных. Гарантируется, что другие транзакции не могут 				читать не закомиченные данные(грязное чтение). Данные, прочитанные в одной транзакции, могут быть обновлены в других транзакциях(работа с 			динамическими данными).
	ISOLATION_REPEATAВLE_READ - Прочитанные данные могут менятся паралельными транзакциями но внутри самой транзакции изменения не будут видны(что прочел 	в начале, с тем и работай).
	ISOLATION_SERIALIZAВLE - Параллельная транзакция не может ни изменить, ни удалить, ни вставить новые строки(Блокировка).

	Режимы распространения транзакций:
	PROPAGATION_REQUIRED - Поддерживает транзакцию, если она уже существует. А если транзакция отсутствует, то начинается новая транзакция.
	PROPAGATION_SUPPORTS - Поддерживает транзакцию, если она уже существует. А если транзакция отсутствует, то выполнение осуществляется без транзакций.
	PROPAGATION_МANDATORY - Поддерживает транзакцию, если она уже существует. А если активная транзакция отсутствует, то генерируется исключение.
	PROPAGATION_REQUIRES_NEW - Всегда начинает новую транзакцию. Если активная транзакция уже существует, она приостанавливается.
	PROPAGATION_NOT_SUPPORTED - Не поддерживает выполнение с активной транзакцией. Всегда выполняется без транзакций и приостанавливает любые 			существующие транзакции.
	PROPAGATION_NEVER - Всегда выполняется без транзакций, даже если имеется активная транзакция. Если же активная транзакция существует, генерируется 		исключение.
	PROPAGATION_NESTED - Выполняется во вложенной транзакции, если существует активная транзакция. А если активная транзакция отсутствует, то выполняется 	так, как будто установлено значение PROPAGATION REQUIRED.
	
	TransactionStatus - setRollbackOnly() - откат, flush() - слияние.

	

	



	







